<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Roulette de IODA</title>

    <!-- React Libraries from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* General Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        #root {
            width: 100%;
            max-width: 1200px;
        }

        /* Title */
        .main-title {
            text-align: center;
            color: #1a237e;
            font-size: 2.5em;
            margin-bottom: 30px;
            font-weight: 300;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            justify-content: center;
        }

        .panel {
            flex: 1;
            min-width: 350px;
            max-width: 550px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 25px;
        }

        h2 {
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 0;
            color: #3f51b5;
        }

        /* Left Panel - Options List */
        .options-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .option-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 10px;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }
        
        .option-item:last-child {
            border-bottom: none;
        }

        .option-item:hover {
            background-color: #f9f9f9;
        }

        .option-item .option-text {
            flex-grow: 1;
            word-break: break-all;
        }

        .option-item .buttons {
            display: flex;
            gap: 8px;
            margin-left: 10px;
        }

        /* Form elements */
        .add-form {
            display: flex;
            margin-top: 20px;
            gap: 10px;
        }

        input[type="text"] {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 1em;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            background-color: #3f51b5;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #303f9f;
        }

        button:active {
            transform: scale(0.95);
        }
        
        button.delete-btn { background-color: #d32f2f; }
        button.delete-btn:hover { background-color: #c62828; }
        button.rename-btn { background-color: #f57c00; }
        button.rename-btn:hover { background-color: #ef6c00; }
        button.save-btn { background-color: #388e3c; }
        button.save-btn:hover { background-color: #2e7d32; }

        /* Right Panel - Roulette Wheel */
        .roulette-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }

        #roulette-canvas {
            max-width: 100%;
            height: auto;
        }
        
        .spin-button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #1a237e;
        }

        .spin-button:disabled {
            background-color: #9e9e9e;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ROULETTE CANVAS COMPONENT ---
        const RouletteCanvas = ({ options, onSpinFinish }) => {
            const canvasRef = useRef(null);
            const [isSpinning, setIsSpinning] = useState(false);
            
            // Using refs to store values that persist between renders without causing re-renders
            const spinTimeRef = useRef(0);
            const spinTimeTotalRef = useRef(0);
            const startAngleRef = useRef(0);
            const spinAngleStartRef = useRef(0);
            const animationFrameIdRef = useRef(null);

            const drawRouletteWheel = useCallback(() => {
                if (!canvasRef.current) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                const outsideRadius = 200;
                const textRadius = 160;
                const insideRadius = 100;
                const arc = Math.PI / (options.length / 2);
                
                const getColor = (item, maxitem) => {
                    const phase = 0;
                    const center = 128;
                    const width = 127;
                    const frequency = Math.PI * 2 / maxitem;
                    const red = Math.sin(frequency * item + 2 + phase) * width + center;
                    const green = Math.sin(frequency * item + 0 + phase) * width + center;
                    const blue = Math.sin(frequency * item + 4 + phase) * width + center;
                    return `rgb(${red}, ${green}, ${blue})`;
                };
                
                ctx.clearRect(0, 0, 500, 500);
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.font = 'bold 14px Helvetica, Arial';

                for (let i = 0; i < options.length; i++) {
                    const angle = startAngleRef.current + i * arc;
                    ctx.fillStyle = getColor(i, options.length);
                    
                    ctx.beginPath();
                    ctx.arc(250, 250, outsideRadius, angle, angle + arc, false);
                    ctx.arc(250, 250, insideRadius, angle + arc, angle, true);
                    ctx.stroke();
                    ctx.fill();
                    
                    ctx.save();
                    ctx.shadowOffsetX = -1;
                    ctx.shadowOffsetY = -1;
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = "rgb(220,220,220)";
                    ctx.fillStyle = "white";
                    ctx.translate(250 + Math.cos(angle + arc / 2) * textRadius, 250 + Math.sin(angle + arc / 2) * textRadius);
                    ctx.rotate(angle + arc / 2 + Math.PI / 2);
                    const text = options[i];
                    ctx.fillText(text, -ctx.measureText(text).width / 2, 0);
                    ctx.restore();
                }

                // Arrow
                ctx.fillStyle = "#333";
                ctx.beginPath();
                ctx.moveTo(250 - 4, 250 - (outsideRadius + 15));
                ctx.lineTo(250 + 4, 250 - (outsideRadius + 15));
                ctx.lineTo(250 + 4, 250 - (outsideRadius - 0));
                ctx.lineTo(250 + 9, 250 - (outsideRadius - 0));
                ctx.lineTo(250 + 0, 250 - (outsideRadius - 10));
                ctx.lineTo(250 - 9, 250 - (outsideRadius - 0));
                ctx.lineTo(250 - 4, 250 - (outsideRadius - 0));
                ctx.lineTo(250 - 4, 250 - (outsideRadius + 15));
                ctx.fill();

            }, [options]);
            
            useEffect(() => {
                drawRouletteWheel();
                // Cleanup animation frame on unmount
                return () => {
                    if(animationFrameIdRef.current) {
                        cancelAnimationFrame(animationFrameIdRef.current);
                    }
                }
            }, [drawRouletteWheel]);


            const stopRotateWheel = () => {
                cancelAnimationFrame(animationFrameIdRef.current);
                const degrees = startAngleRef.current * 180 / Math.PI + 90;
                const arcd = (Math.PI / (options.length / 2)) * 180 / Math.PI;
                const index = Math.floor((360 - degrees % 360) / arcd);
                
                const ctx = canvasRef.current.getContext('2d');
                ctx.save();
                ctx.font = 'bold 30px Helvetica, Arial';
                const text = options[index];
                ctx.fillStyle = "#333";
                ctx.fillText(text, 250 - ctx.measureText(text).width / 2, 250 + 10);
                ctx.restore();
                
                setIsSpinning(false);
                onSpinFinish(text);
            };

            const easeOut = (t, b, c, d) => {
                const ts = (t /= d) * t;
                const tc = ts * t;
                return b + c * (tc + -3 * ts + 3 * t);
            };
            
            const rotateWheel = (timestamp) => {
                const elapsed = timestamp - spinTimeRef.current;
                
                if (elapsed >= spinTimeTotalRef.current) {
                    stopRotateWheel();
                    return;
                }

                const spinAngle = spinAngleStartRef.current - easeOut(elapsed, 0, spinAngleStartRef.current, spinTimeTotalRef.current);
                startAngleRef.current += (spinAngle * Math.PI / 180);
                drawRouletteWheel();
                animationFrameIdRef.current = requestAnimationFrame(rotateWheel);
            };

            const handleSpin = () => {
                if (isSpinning || options.length < 2) return;
                setIsSpinning(true);
                
                spinAngleStartRef.current = Math.random() * 10 + 10;
                spinTimeTotalRef.current = Math.random() * 3000 + 4000; // 4-7 seconds spin
                
                requestAnimationFrame((timestamp) => {
                  spinTimeRef.current = timestamp; // Set start time
                  rotateWheel(timestamp);
                });
            };

            return (
                <div className="roulette-container">
                    <canvas id="roulette-canvas" ref={canvasRef} width="500" height="500" />
                    <button className="spin-button" onClick={handleSpin} disabled={isSpinning || options.length < 2}>
                        {isSpinning ? 'Ça tourne...' : 'Lancer la roue !'}
                    </button>
                </div>
            );
        };

        // --- OPTIONS PANEL COMPONENT ---
        const OptionsPanel = ({ options, onAdd, onDelete, onRename }) => {
            const [newOption, setNewOption] = useState('');
            const [editingIndex, setEditingIndex] = useState(null);
            const [editingText, setEditingText] = useState('');

            const handleAddOption = (e) => {
                e.preventDefault();
                if (newOption.trim()) {
                    onAdd(newOption.trim());
                    setNewOption('');
                }
            };

            const handleStartRename = (index, text) => {
                setEditingIndex(index);
                setEditingText(text);
            };
            
            const handleSaveRename = (index) => {
                onRename(index, editingText);
                setEditingIndex(null);
                setEditingText('');
            };

            return (
                <div>
                    <h2>Options</h2>
                    <ul className="options-list">
                        {options.map((option, index) => (
                            <li key={index} className="option-item">
                                {editingIndex === index ? (
                                    <>
                                        <input
                                            type="text"
                                            value={editingText}
                                            onChange={(e) => setEditingText(e.target.value)}
                                            onKeyPress={(e) => e.key === 'Enter' && handleSaveRename(index)}
                                            autoFocus
                                        />
                                        <div className="buttons">
                                            <button className="save-btn" onClick={() => handleSaveRename(index)}>✓</button>
                                        </div>
                                    </>
                                ) : (
                                    <>
                                        <span className="option-text">{option}</span>
                                        <div className="buttons">
                                            <button className="rename-btn" onClick={() => handleStartRename(index, option)}>✎</button>
                                            <button className="delete-btn" onClick={() => onDelete(index)}>✕</button>
                                        </div>
                                    </>
                                )}
                            </li>
                        ))}
                    </ul>
                    <form className="add-form" onSubmit={handleAddOption}>
                        <input
                            type="text"
                            value={newOption}
                            onChange={(e) => setNewOption(e.target.value)}
                            placeholder="Ajouter une nouvelle option..."
                        />
                        <button type="submit">Ajouter</button>
                    </form>
                </div>
            );
        };
        
        // --- MAIN APP COMPONENT ---
        const App = () => {
            const defaultOptions = ['SoFresh', 'Sonny Boy', 'Bobun', 'Japonais', 'MonMarché', 'Libanais', 'Picard', 'Chinois'];
            const [options, setOptions] = useState(defaultOptions);

            const handleAddOption = (optionText) => {
                if (!options.includes(optionText)) {
                    setOptions([...options, optionText]);
                }
            };
            
            const handleDeleteOption = (indexToDelete) => {
                setOptions(options.filter((_, index) => index !== indexToDelete));
            };
            
            const handleRenameOption = (index, newText) => {
                if (newText.trim()) {
                    const updatedOptions = [...options];
                    updatedOptions[index] = newText.trim();
                    setOptions(updatedOptions);
                }
            };
            
            const handleSpinFinish = (winner) => {
                setTimeout(() => {
                    alert(`Le gagnant est : ${winner} ! On y va !`);
                }, 100); // Small delay to let the final frame render
            };
            
            return (
                <div>
                    <h1 className="main-title">La roulette de IODA où on mange à midi ? (à 11h)</h1>
                    <div className="app-container">
                        <div className="panel">
                            <OptionsPanel
                                options={options}
                                onAdd={handleAddOption}
                                onDelete={handleDeleteOption}
                                onRename={handleRenameOption}
                            />
                        </div>
                        <div className="panel">
                            <RouletteCanvas options={options} onSpinFinish={handleSpinFinish} />
                        </div>
                    </div>
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>

</body>
</html>